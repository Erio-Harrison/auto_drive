![result](/asset/system_design.png)

# 分布式系统框架介绍

如引言中所说，我们的系统大致分为感知、规划和控制三个模块，而为了开发方便，我们往往会把这三个模块继续拆分成子模块。比如这里我把**感知模块**又拆成了**检测模块（ObstacleDetectionNode）**和**追踪模块（ObstacleTrackingNode）**，前者用于模拟初次检测障碍物，后者用来模拟追踪障碍物。

来自硬件检测的数据点中，会有很多无效数据点的存在。通过这种分离，我们可以在**检测模块**中做初步处理，然后在**追踪模块**中追踪实际有效的数据点。比如在我们目前系统的简易实现里，我们在**检测模块**里用简单的**K-means聚类**算法来过滤庞大的点云数据集，把有效的数据点发布给**追踪模块**,在**追踪模块**当中用**卡尔曼滤波器**来完成数据的预测和追踪。

当然，一切的数据来源是硬件，在这里，我们是通过**LidarSimulatorNode**来模拟来自硬件的数据。

**ObstacleTrackingNode**把追踪后的数据传给**路径规划模块(PathPlanningNode)**。**PathPlanningNode**根据接收到的障碍物数据，做出路径规划（我们暂时使用的是简单的**A*算法**），再把规划好的路径数据发送给**车辆控制模块（VehicleControlNode）**。**VehicleControlNode**会根据路径规划和目前的车辆状态，计算得到指令（加速、减速、转向等等）并更新车辆状态（位置、速度、加速度等等）。

所有的无人车辆都可以通过**网络通信模块（NetworkBridgeNode）** 接收来自 **VehicleControlNode** 的信息，然后和 **模拟中央服务器（MockServerNode）** 进行网络通信。

数据传递过程中涉及到的具体数据类型是**ROS2**的内置数据类型，后面代码实现的时候会具体介绍（当然，直接看架构图应该也可以看懂它们大致是干什么用的）。我们希望可视化看到这整个流程，所以**ObstacleDetectionNode**、**ObstacleTrackingNode**、**PathPlanningNode**、**VehicleControlNode**会把数据传给**AutoDriveVisualizerNode**，让我们可以看到自己的成果。

通过充分利用**ROS2**的**数据分发服务(Data distribution service，DDS)**，我们可以实现**分布式架构**。比如在计算机A上运行**ObstacleDetectionNode**，在计算机B上运行**ObstacleTrackingNode**，这两个节点将通过**DDS**的自动发现机制相互发现，并通过发布-订阅模式进行通信。

# lidar_simulator_node

正式开始代码部分了，假设你已经安装好了**ROS2**环境，然后我们来创建工作空间(就是建文件夹)：

```bash
mkdir -p write-you-an-autopilot-sys/src
```

```bash
cd src
```

所有功能模块在ROS2环境中都是通过专门的功能包来实现，要创建一个新的功能包，是用下面这个语法：

```bash
ros2 pkg create <新建功能包的名字> --build-type {cmake,ament_cmake,ament_python} --dependencies <依赖项>
```

**pkg**: 表示功能包相关的功能

**create**：表示创建功能包

**build-type**：表示新创建的功能包是C++还是Python的，如果使用C++或者C，这里就跟ament_cmake，如果使用Python，就跟ament_python

**package_name**：新建功能包的名字

我们来为`lidar_simulator_node`创建叫做`sensor_simulator`的功能包：

```bash
ros2 pkg create sensor_simulator --build-type ament_cmake --dependencies rclcpp
```

进入这个功能包的工作区间**src**，新建 **lidar_simulator_node.cpp**，然后就可以开始愉快的写C++代码啦！！

**lidar_simulator_node.cpp**实现逻辑很简单，利用随机数来生成数据（在这个教学项目的简易实现里，主要需要的是每组随机三个数字x y z，用于表示三维坐标），我们通过review它的代码实现来讲解一下ROS2里的固定写法，先来看主函数里的这三行代码：

```bash
int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<LidarSimulatorNode>());
    rclcpp::shutdown();
    return 0;
}
```

这里先调用`rclcpp::init`函数初始化ROS 2环境，然后用`std::make_shared<LidarSimulatorNode>()`创建一个**LidarSimulatorNode**对象并调用`rclcpp::spin`函数使其进入事件循环。`rclcpp::spin`函数会持续运行，直到节点被关闭或程序被中断。当节点不再需要运行时，调用`rclcpp::shutdown`函数来清理资源并关闭ROS2环境。

我们来看看用`std::make_shared<LidarSimulatorNode>()`创建一个**LidarSimulatorNode**对象的时候发生了什么：

我们通过这里的构造函数来初始化成员变量

```bash
LidarSimulatorNode() : Node("lidar_simulator"), gen(rd()), dis(-10.0, 10.0)
{
    publisher_ = this->create_publisher<sensor_msgs::msg::PointCloud2>("simulated_pointcloud", 10);
    timer_ = this->create_wall_timer(
        std::chrono::seconds(1),
        std::bind(&LidarSimulatorNode::publish_simulated_pointcloud, this));
}
```

其中这三个成员变量是用来生成随机数的

```bash
std::random_device rd;
std::mt19937 gen;
std::uniform_real_distribution<> dis;
```

初始化阶段，我们采用`gen(rd)`作为固定的初始化方式，同时使用`dis`来指定随机数的范围为-10到10（即`dis(-10.0, 10.0)`）。这种随机数生成方式主要用于模拟激光雷达（LiDAR）传感器和深度相机等设备采集到的数据。这些设备通常输出的数据类型为**点云数据**。在这里，`PointCloud2`消息类型被用来接收和处理这些数据，以便后续的数据处理和分析。

`rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr publisher_`这个成员变量的作用是发布 `PointCloud2` 类型的消息到 ROS2 系统中，在构造函数`publisher_ = this->create_publisher<sensor_msgs::msg::PointCloud2>("simulated_pointcloud", 10)`这里完成了初始化，这个初始化的意义是发布者要发布的消息的**topic**名称是`simulated_pointcloud`,`10` 是发布者的队列大小，表示最多可以缓存多少条待发送的消息。

`rclcpp::TimerBase::SharedPtr timer_`这个成员变量用于存储一个指向 `rclcpp::TimerBase` 对象的智能指针。rclcpp::TimerBase 是 ROS2中的一个定时器类，用于在特定的时间间隔内触发回调函数。我们看到，在初始化的时候，它绑定了`publish_simulated_pointcloud`,同时设定`std::chrono::seconds(1)`, 这意味着，当我们用`rclcpp::spin(std::make_shared<LidarSimulatorNode>())`运行`lidar_simulator`这个Node的时候，每隔一秒才会调用一次`publish_simulated_pointcloud`函数。

成员变量初始化工作完成，接下来看`publish_simulated_pointcloud`函数的实现：

注意，我们是使用`publisher_->publish(cloud)`来发布点云数据，在这个函数里，我们做的唯一一件事情就是修改**PointCloud2**类型的数据:`cloud`。所以我们只需要理解**PointCloud2**类型的数据具备哪些基本元素就好，下面是它的基本元素：

1. header (std_msgs::Header)

- stamp: 时间戳，表示点云数据的采集时间
- frame_id: 字符串，表示点云数据的坐标系

2. height (uint32)

- 点云的高度。对于无序点云，通常设置为1

3. width (uint32)

- 点云的宽度。对于无序点云，这表示点的总数

4. fields (sensor_msgs::PointField[])

描述每个点的数据结构。每个PointField包含：

- name: 字段名称（如 "x", "y", "z", "intensity" 等）
- offset: 字段在点结构中的字节偏移
- datatype: 数据类型（如 FLOAT32, UINT8 等）
- count: 该字段的元素数量

5. is_bigendian (bool)

- 指示数据是否以大端格式存储

6. point_step (uint32)

- 单个点占用的字节数

7. row_step (uint32)

- 一行点占用的字节数（对于有序点云）

8. data (uint8[])

- 实际的点云数据，以连续的字节数组形式存储

9. is_dense (bool)

- 指示点云是否包含无效点

```bash
for (size_t i = 0; i < cloud.height * cloud.width; ++i)
{
    float x = dis(gen);
    float y = dis(gen);
    float z = dis(gen) / 2.0;

    memcpy(&cloud.data[i * cloud.point_step + 0], &x, sizeof(float));
    memcpy(&cloud.data[i * cloud.point_step + 4], &y, sizeof(float));
    memcpy(&cloud.data[i * cloud.point_step + 8], &z, sizeof(float));
}
```
随机生成数字后，用`memcpy`复制给点云数据的对应位置，然后使用`publisher_->publish(cloud)`发布我们的数据到ROS2系统。

好，到这里，我们的雷达模拟节点`lidar_simulator_node`就实现了,注意修改**cmakelist** 和 **package.xml**,添加相关的依赖。